{
    "sourceFile": "msaBase/configurate.py",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1670579212434,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1670579212434,
            "name": "Commit-0",
            "content": "# -*- coding: utf-8 -*-\n\"\"\"Main Service Module for MSAApp.\n\nInitialize with a MSAServiceDefintion Instance to control the features and functions of the MSAApp.\n\n\"\"\"\nimport os\nfrom asyncio import Task\nfrom datetime import datetime\nfrom typing import Any, Dict, List, Optional, Type, Union\n\nfrom dapr.clients import DaprClient\nfrom fastapi import FastAPI, HTTPException\nfrom fastapi.encoders import jsonable_encoder\nfrom fastapi.exception_handlers import http_exception_handler\nfrom fastapi.exceptions import RequestValidationError\nfrom fastapi.responses import ORJSONResponse\nfrom loguru import logger as logger_gruru\nfrom msaDocModels.health import MSAHealthDefinition, MSAHealthMessage\nfrom msaDocModels.openapi import MSAOpenAPIInfo\nfrom msaDocModels.scheduler import (\n    MSASchedulerStatus,\n    MSASchedulerTaskDetail,\n    MSASchedulerTaskStatus,\n)\nfrom msaDocModels.sdu import SDUVersion\nfrom starlette import status\nfrom starlette.exceptions import HTTPException as StarletteHTTPException\nfrom starlette.requests import Request\nfrom starlette.responses import HTMLResponse, JSONResponse, Response\nfrom starlette_context import plugins\n\nfrom msaBase.config import MSAServiceDefinition, MSAServiceStatus\nfrom msaBase.errorhandling import getMSABaseExceptionHandler\nfrom msaBase.logger import init_logging\nfrom msaBase.models.functionality import FunctionalityTypes\nfrom msaBase.models.middlewares import MiddlewareTypes\nfrom msaBase.models.sysinfo import MSASystemInfo\nfrom msaBase.sysinfo import get_sysinfo\n\n\ndef getSecretKey() -> str:\n    \"\"\"\n    Get Secret Key for Token creation from OS Environment Variable **SECRET_KEY_TOKEN**\n\n    Returns:\n        key: The SECRET_KEY_TOKEN.\n\n    \"\"\"\n    key: str = os.getenv(\n        \"SECRET_KEY_TOKEN\",\n        \"u2dmsaservicex_#M8A{1o3Bd?<ipwt^K},Z)OE<Fkj-X9IILWq|Cf`Y:HFI~&2L%Ion3}+p{T%\",\n    )\n    return key\n\n\ndef getSecretKeySessions() -> str:\n    \"\"\"\n    Get Secret Key for Session Middleware from OS Environment Variable **SECRET_KEY_SESSIONS**\n\n    Returns:\n        key: The SECRET_KEY_SESSIONS.\n\n    \"\"\"\n    key: str = os.getenv(\n        \"SECRET_KEY_SESSIONS\",\n        \"u2dmsaserviceeP)zg5<g@4WJ0W8'?ad!T9UBvW1z2k|y~|Pgtewv=H?GY_Q]t~-~UUe'pJ0V[>!<)\",\n    )\n    return key\n\n\ndef getSecretKeyCSRF() -> str:\n    \"\"\"\n    Get Secret Key for CSRF Middleware from OS Environment Variable **SECRET_KEY_CSRF**\n\n    Returns:\n        key: The SECRET_KEY_CSRF.\n\n    \"\"\"\n    key: str = os.getenv(\n        \"SECRET_KEY_CSRF\",\n        \"u2dmsaservicee_rJM'onkEV1trD=I7dci$flB)aSNW+raL4j]Ww=n~_BRg35*3~(E.>rx`1aTw:s\",\n    )\n    return key\n\n\nclass MSAApp(FastAPI):\n    \"\"\"Creates an application msaBase instance.\n\n    Note:\n        As with FastApi the MSAApp provides two events:\n        ``startup``: A list of callables to run on application startup. Startup handler callables do not take any arguments, and may be be either standard functions, or async functions.\n        ``shutdown``: A list of callables to run on application shutdown. Shutdown handler callables do not take any arguments, and may be be either standard functions, or async functions.\n        Those are also used internally, which are triggered before the external events.\n\n        Do not include the `self` parameter in the ``Args`` section.\n\n    Args:\n        settings: MSAServiceDefinition (Must be provided), instance of a service definition with all settings\n        sql_models: List of SQLModel Default None, provide list of your SQLModel Classes and the instance can create CRUD API and if site is enabled also UI for CRUD\n        auto_mount_site: Default True, if site is enabled in settings and this is true, mounts the site in internal startup event.\n\n    Attributes:\n        logger: loguru logger instance\n        auto_mount_site: bool auto_mount_site\n        settings: MSAServiceDefinition settings instance.\n        healthdefinition: MSAHealthDefinition settings.healthdefinition\n        limiter: Limiter = None\n        scheduler: MSAScheduler = None\n        scheduler_task: The Task instance that runs the Scheduler in the Background\n        ROOTPATH: str os.path.join(os.path.dirname(__file__))\n\n    \"\"\"\n\n    def __init__(\n        self,\n        settings: MSAServiceDefinition,\n        auto_mount_site: bool = True,\n        title: str = \"FastAPI\",\n        description: str = \"\",\n        version: str = \"0.1.0\",\n        openapi_url: Optional[str] = \"/openapi.json\",\n        openapi_tags: Optional[List[Dict[str, Any]]] = None,\n        terms_of_service: Optional[str] = None,\n        contact: Optional[Dict[str, Union[str, Any]]] = None,\n        license_info: Optional[Dict[str, Union[str, Any]]] = None,\n        *args,\n        **kwargs,\n    ) -> None:\n        # call super class __init__\n        super().__init__(*args, **settings.fastapi_kwargs)\n\n        self.logger = logger_gruru\n        self.fastApi = FastAPI\n        self.title = title\n        self.description = description\n        self.version = version\n        self.openapi_url = openapi_url\n        self.auto_mount_site: bool = auto_mount_site\n        self.settings = settings\n        self.SDUVersion = SDUVersion(\n            version=self.settings.version, creation_date=datetime.utcnow().isoformat()\n        )\n        self.license_info = license_info\n        self.contact = contact\n        self.terms_of_service = terms_of_service\n        self.openapi_tags = openapi_tags\n        self.healthdefinition: MSAHealthDefinition = self.settings.healthdefinition\n        self.limiter: \"Limiter\" = None\n        self.background_scheduler: \"BackgroundScheduler\" = None\n        self.asyncio_scheduler: \"AsyncIOScheduler\" = None\n        self.site = None\n        self._scheduler_task: Task = None\n        self.ROOTPATH = os.path.join(os.path.dirname(__file__))\n        self.abstract_fs: \"MSAFilesystem\" = None\n        self.fs: \"FS\" = None\n        self.healthcheck: \"health.MSAHealthCheck\" = None\n        self.logger.info_pub = self.logger_info\n\n        init_logging()\n        self.add_middlewares()\n        self.add_functionality()\n        self.logger.info(\"Events - Add Internal Handlers\")\n        self.add_event_handler(\"shutdown\", self.shutdown_event)\n        self.add_event_handler(\"startup\", self.startup_event)\n\n    def logger_info(self, message: str, topic_name: str = \"\"):\n        if topic_name:\n            with DaprClient() as client:\n                client.publish_event(\n                    pubsub_name=\"spkpubsub\",\n                    topic_name=topic_name,\n                    data=message,\n                    data_content_type=\"application/json\",\n                )\n        self.logger.info(message)\n\n    async def extend_startup_event(self) -> None:\n        \"\"\"You can extend the main shutdown\"\"\"\n\n    async def startup_event(self) -> None:\n        \"\"\"Internal Startup Event Handler\"\"\"\n        self.logger.info(\"msaBase Internal Startup MSAUIEvent\")\n        await self.extend_startup_event()\n\n    async def extend_shutdown_event(self) -> None:\n        \"\"\"You can extend the main shutdown\"\"\"\n\n    async def shutdown_event(self) -> None:\n        \"\"\"Internal Shutdown event handler\"\"\"\n        self.logger.info(\"msaBase Internal Shutdown MSAUIEvent\")\n        await self.extend_shutdown_event()\n\n        if self.settings.background_scheduler and self.background_scheduler.get_jobs():\n            self.logger.info(\"Stop Background Scheduler\")\n            self.background_scheduler.shutdown()\n\n        if self.settings.asyncio_scheduler and self.asyncio_scheduler.get_jobs():\n            self.logger.info(\"Stop Asyncio Scheduler\")\n            self.asyncio_scheduler.shutdown()\n\n        if self.healthcheck:\n            self.logger.info(\"Stopping Healthcheck Thread\")\n            await self.healthcheck.stop()\n            self.healthcheck = None\n\n        if self.settings.abstract_fs:\n            try:\n                self.logger.info(\"Closing Abstract Filesystem\")\n                self.fs.close()\n            except Exception as ex:\n                getMSABaseExceptionHandler().handle(\n                    ex, \"Error: Closing Abstract Filesystem failed:\"\n                )\n\n    async def get_healthcheck(self, request: Request) -> ORJSONResponse:\n        \"\"\"\n        Get Healthcheck Status\n        \"\"\"\n        self.logger.info(\"Called - get_healthcheck :\" + str(request.url))\n        msg: MSAHealthMessage = MSAHealthMessage()\n        if not self.healthcheck:\n            msg.message = \"Healthcheck is disabled!\"\n        else:\n            msg.healthy = self.healthcheck.is_healthy\n            msg.message = await self.healthcheck.get_health()\n            if len(self.healthcheck.error) > 0:\n                msg.error = self.healthcheck.error\n\n        return ORJSONResponse(content=jsonable_encoder(msg))\n\n    async def get_scheduler_status(self, request: Request) -> MSASchedulerStatus:\n        \"\"\"\n        Get Service Scheduler Status, with the registered Task's\n\n        Args:\n            request: The input http request object\n\n        Returns:\n            sst: MSASchedulerStatus Pydantic Response Model\n\n        \"\"\"\n        self.logger.info(\"Called - get_scheduler_status :\" + str(request.url))\n        sst: MSASchedulerStatus = MSASchedulerStatus()\n        if (\n            not self.settings.background_scheduler\n            or not self.settings.asyncio_scheduler\n        ):\n            sst.name = self.settings.name\n            sst.message = \"Schedulers is disabled!\"\n\n        else:\n            sst.name = self.settings.name\n            for task in self.background_scheduler.get_jobs():\n                nt: MSASchedulerTaskStatus = MSASchedulerTaskStatus()\n                nt.name = task.name\n                nt.detail = MSASchedulerTaskDetail.parse_obj(task)\n                sst.tasks.append(nt)\n            for task in self.asyncio_scheduler.get_jobs():\n                nt: MSASchedulerTaskStatus = MSASchedulerTaskStatus()\n                nt.name = task.name\n                nt.detail = MSASchedulerTaskDetail.parse_obj(task)\n                sst.tasks.append(nt)\n            sst.message = \"Scheduler is enabled!\"\n\n        return sst\n\n    async def get_services_status(self, request: Request) -> MSAServiceStatus:\n        \"\"\"\n        Get Service Status Info\n\n        Args:\n            request: The input http request object\n\n        Returns:\n            sst: MSAServiceStatus Pydantic Response Model\n\n        \"\"\"\n        self.logger.info(\"Called - get_services_status :\" + str(request.url))\n        sst: MSAServiceStatus = MSAServiceStatus()\n        if not self.healthcheck:\n            sst.name = self.settings.name\n            sst.healthy = \"disabled:400\"\n            sst.message = \"Healthcheck is disabled!\"\n\n        else:\n            sst.name = self.settings.name\n            sst.healthy = await self.healthcheck.get_health()\n            sst.message = \"Healthcheck is enabled!\"\n\n        return sst\n\n    def get_services_definition(self, request: Request) -> MSAServiceDefinition:\n        \"\"\"\n        Get Service Definition Info\n\n        Args:\n            request: The input http request object\n\n        Returns:\n            settings: MSAServiceDefinition Pydantic Response Model\n\n        \"\"\"\n        self.logger.info(\"Called - get_services_definition :\" + str(request.url))\n        return self.settings\n\n    def get_services_settings(self, request: Request) -> ORJSONResponse:\n        \"\"\"\n        Get Service OpenAPI Schema\n\n        Args:\n            request: The input http request object\n\n        Returns:\n            settings: ORJSONResponse\n\n        \"\"\"\n        self.logger.info(\"Called - get_services_settings :\" + str(request.url))\n\n        def try_get_json():\n            try:\n\n                return jsonable_encoder(self.settings)\n\n            except Exception as e:\n                return {\"status\": \"error:400\", \"error\": e.__str__()}\n\n        return ORJSONResponse(\n            {\n                self.settings.name: try_get_json(),\n            }\n        )\n\n    def get_services_openapi_schema(self, request: Request) -> ORJSONResponse:\n        \"\"\"\n        Get Service OpenAPI Schema\n\n        Args:\n            request: The input http request object\n\n        Returns:\n            openapi: ORJSONResponse openapi schema\n\n\n        \"\"\"\n        self.logger.info(\"Called - get_services_openapi_schema :\" + str(request.url))\n\n        def try_get_json():\n            try:\n\n                return jsonable_encoder(self.openapi())\n\n            except Exception as e:\n                return {\"status\": \"error:400\", \"error\": e.__str__()}\n\n        return ORJSONResponse(\n            {\n                self.settings.name: try_get_json(),\n            }\n        )\n\n    async def msa_exception_handler(\n        self, request: Request, exc: HTTPException\n    ) -> Response:\n        \"\"\"\n        Handles all HTTPExceptions if enabled with HTML Response or forward error if the code is in the exclude settings list.\n\n        Args:\n            request: The input http request object\n            exc : The HTTPException instance\n\n        Returns:\n            HTTPException\n\n        \"\"\"\n        error_content = {\n            \"request\": request.__dict__,\n            \"detail\": exc.detail,\n            \"status\": exc.status_code,\n            \"definitions\": jsonable_encoder(self.settings),\n        }\n        self.logger.error(\"msa_exception_handler - \" + str(error_content))\n        return await http_exception_handler(request, exc)\n\n    def get_sduversion(self) -> SDUVersion:\n        \"\"\"Get SDUVersion\n        Returns:\n            sdu_version: Pydantic Version Info Model.\n\n        \"\"\"\n        return self.SDUVersion\n\n    def get_services_openapi_info(self, request: Request) -> MSAOpenAPIInfo:\n        \"\"\"\n        Get Service OpenAPI Info\n\n        Args:\n            request: The input http request object\n\n        Returns:\n            oai: MSAOpenAPIInfo Paydantic Response Model\n\n        \"\"\"\n        self.logger.info(\"Called - get_services_openapi_info :\" + str(request.url))\n        oai: MSAOpenAPIInfo = MSAOpenAPIInfo()\n\n        try:\n            oai.name = self.title\n            oai.version = self.openapi_version\n            oai.url = self.openapi_url\n            oai.tags = self.openapi_tags\n        except Exception as e:\n            oai.tags = [\"error:400 error\" + e.__str__()]\n\n        return oai\n\n    async def validation_exception_handler(\n        self, request: Request, exc: RequestValidationError\n    ) -> JSONResponse:\n        self.logger.error(\"validation_exception_handler - \" + str(exc.errors()))\n        return JSONResponse(\n            status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,\n            content=jsonable_encoder({\"detail\": exc.errors(), \"body\": exc.body}),\n        )\n\n    async def msa_exception_handler_disabled(\n        self, request: Request, exc: HTTPException\n    ) -> JSONResponse:\n        \"\"\"\n        Handles all HTTPExceptions if Disabled with JSON Response.\n\n        Args:\n            request: The input http request object\n\n        Returns:\n            HTTPException: as JSONResponse\n\n        \"\"\"\n\n        error_content = jsonable_encoder(\n            {\n                \"status_code\": exc.status_code,\n                \"detail\": exc.detail,\n                \"args\": exc.args,\n                \"headers\": exc.headers,\n                \"request\": request.url,\n            }\n        )\n        self.logger.error(\"msa_exception_handler_disabled - \" + str(error_content))\n        return JSONResponse(\n            status_code=exc.status_code,\n            content=error_content,\n        )\n\n    def add_middlewares(self) -> None:\n        \"\"\"\n        Add Middleware, by values in Settings\n        \"\"\"\n        for middleware in MiddlewareTypes:\n            try:\n                status_middleware = getattr(self.settings, middleware.name, None)\n                if status_middleware:\n                    self.choose_middleware_configurator(middleware)()\n                else:\n                    self.logger.info(f\"Excluded {middleware.readable_name}\")\n            except Exception as ex:\n                getMSABaseExceptionHandler().handle(ex)\n\n    def add_functionality(self) -> None:\n        \"\"\"\n        Add Functionality, by values in Settings\n        \"\"\"\n        for functionality in FunctionalityTypes:\n            try:\n                status_middleware = getattr(self.settings, functionality.name, None)\n                if status_middleware:\n                    self.choose_functionality_configurator(functionality)()\n                else:\n                    self.logger.info(f\"Excluded {functionality.readable_name}\")\n            except Exception as ex:\n                getMSABaseExceptionHandler().handle(ex)\n\n    def unknown_middleware(self) -> None:\n        \"\"\"\n        Unknown Middleware, doing nothing\n        \"\"\"\n        self.logger.info(\"Unknown Middleware\")\n\n    def unknown_functionality(self) -> None:\n        \"\"\"\n        Unknown Functionality, doing  nothing\n        \"\"\"\n        self.logger.info(\"Unknown Functionality\")\n\n    def choose_middleware_configurator(\n        self, middleware: Union[MiddlewareTypes, FunctionalityTypes]\n    ) -> Type[unknown_middleware]:\n        \"\"\"\n        Get the configurator by type of Middleware\n\n        Returns:\n            func: The configurator.\n\n        \"\"\"\n        configurator_mappings = {\n            MiddlewareTypes.profiler: self.configure_profiler_middleware,\n            MiddlewareTypes.validationception: self.configure_validation_handler,\n            MiddlewareTypes.httpception: self.configure_httpexception_handler,\n            MiddlewareTypes.starception: self.configure_starception_middleware,\n            MiddlewareTypes.cors: self.configure_cors_middleware,\n            MiddlewareTypes.httpsredirect: self.configure_httpsredirect_middleware,\n            MiddlewareTypes.gzip: self.configure_gzip_middleware,\n            MiddlewareTypes.session: self.configure_session_middleware,\n            MiddlewareTypes.csrf: self.configure_csrf_middleware,\n            MiddlewareTypes.msgpack: self.configure_msgpack_middleware,\n            MiddlewareTypes.context: self.configure_context_middleware,\n            MiddlewareTypes.timing: self.configure_timing_middleware,\n            MiddlewareTypes.limiter: self.configure_limiter_handler,\n        }\n        return configurator_mappings.get(middleware, self.unknown_middleware)\n\n    def choose_functionality_configurator(\n        self, middleware: FunctionalityTypes\n    ) -> Type[unknown_functionality]:\n        \"\"\"\n        Get the configurator by type of Functionality\n\n        Returns:\n            func: The configurator.\n\n        \"\"\"\n        configurator_mappings = {\n            FunctionalityTypes.uvloop: self.configure_event_loop,\n            FunctionalityTypes.healthdefinition: self.configure_healthdefinition,\n            FunctionalityTypes.sysrouter: self.configure_sysrouter,\n            FunctionalityTypes.servicerouter: self.configure_servicerouter,\n            FunctionalityTypes.instrument: self.configure_prometheus_instrument,\n            FunctionalityTypes.background_scheduler: self.configure_background_scheduler,\n            FunctionalityTypes.asyncio_scheduler: self.configure_asyncio_scheduler,\n            FunctionalityTypes.abstract_fs: self.configure_abstract_fs,\n        }\n        return configurator_mappings.get(middleware, self.unknown_middleware)\n\n    def configure_starception_middleware(self) -> None:\n        \"\"\"Add Middleware Starception\"\"\"\n        self.logger.info(\"Add Middleware Starception\")\n        from starception import StarceptionMiddleware\n\n        self.add_middleware(StarceptionMiddleware)\n\n    def configure_servicerouter(self) -> None:\n        \"\"\"Add service routers\"\"\"\n        self.logger.info(\"Include Servicerouter\")\n        if self.settings.background_scheduler or self.settings.asyncio_scheduler:\n            self.add_api_route(\n                \"/scheduler\",\n                self.get_scheduler_status,\n                tags=[\"service\"],\n                response_model=MSASchedulerStatus,\n            )\n        self.add_api_route(\n            \"/status\",\n            self.get_services_status,\n            tags=[\"service\"],\n            response_model=MSAServiceStatus,\n        )\n        self.add_api_route(\n            \"/definition\",\n            self.get_services_definition,\n            tags=[\"service\"],\n            response_model=MSAServiceDefinition,\n        )\n        self.add_api_route(\n            \"/sys_info\", get_sysinfo, tags=[\"service\"], response_model=MSASystemInfo\n        )\n        self.add_api_route(\n            \"/\", self.get_sduversion, tags=[\"service\"], response_model=SDUVersion\n        )\n        self.add_api_route(\"/settings\", self.get_services_settings, tags=[\"service\"])\n        self.add_api_route(\n            \"/schema\", self.get_services_openapi_schema, tags=[\"openapi\"]\n        )\n        self.add_api_route(\n            \"/info\",\n            self.get_services_openapi_info,\n            tags=[\"openapi\"],\n            response_model=MSAOpenAPIInfo,\n        )\n\n    def configure_limiter_handler(self) -> None:\n        \"\"\"Add Limiter Handler\"\"\"\n        self.logger.info(\"Add Limiter Handler\")\n        from slowapi import Limiter, _rate_limit_exceeded_handler\n        from slowapi.errors import RateLimitExceeded\n        from slowapi.util import get_remote_address\n\n        self.limiter = Limiter(key_func=get_remote_address)\n        self.state.limiter = self.limiter\n        self.add_exception_handler(RateLimitExceeded, _rate_limit_exceeded_handler)\n\n    def configure_profiler_middleware(self) -> None:\n        \"\"\"Add Middleware Profiler\"\"\"\n        self.logger.info(\"Add Middleware Profiler\")\n        from msaBase.profiler import MSAProfilerMiddleware\n\n        self.add_middleware(\n            MSAProfilerMiddleware,\n            profiler_output_type=self.settings.profiler_output_type,\n            track_each_request=self.settings.profiler_single_calls,\n            msa_app=self,\n        )\n\n    def configure_httpexception_handler(self) -> None:\n        \"\"\"Add Handler HTTPException\"\"\"\n        self.logger.info(\"Add Handler HTTPException\")\n        exception_handler = (\n            self.msa_exception_handler\n            if self.settings.httpception\n            else self.msa_exception_handler_disabled\n        )\n        self.add_exception_handler(StarletteHTTPException, exception_handler)\n\n    def configure_validation_handler(self) -> None:\n        \"\"\"Add Handler ValidationError\"\"\"\n        self.logger.info(\"Add Handler ValidationError\")\n        self.add_exception_handler(\n            RequestValidationError, self.validation_exception_handler\n        )\n\n    def configure_healthdefinition(self) -> None:\n        self.logger.info(\"Init Healthcheck\")\n        from msaBase.healthcheck import MSAHealthCheck\n\n        self.healthcheck = MSAHealthCheck(\n            healthdefinition=self.healthdefinition,\n            host=self.settings.host,\n            port=self.settings.port,\n        )\n        self.logger.info(\"Start Healthcheck Thread\")\n        self.healthcheck.start()\n        self.add_api_route(\n            self.healthdefinition.path,\n            self.get_healthcheck,\n            response_model=MSAHealthMessage,\n            tags=[\"service\"],\n        )\n\n    def configure_sysrouter(self) -> None:\n        \"\"\"Enable Sysrouter\"\"\"\n        self.logger.info(\"Include Sysrouter\")\n        from msaBase.router import sys_router\n\n        self.include_router(sys_router)\n\n    def configure_abstract_fs(self) -> None:\n        \"\"\"Enable Abstract Filesystem\"\"\"\n        self.logger.info(\"Enable Abstract Filesystem\")\n        from msaFilesystem.msafs import MSAFilesystem\n\n        self.abstract_fs = MSAFilesystem(fs_url=self.settings.abstract_fs_url)\n        self.fs = self.abstract_fs.fs\n\n    def configure_msgpack_middleware(self) -> None:\n        \"\"\"Add Middleware MSGPack\"\"\"\n        self.logger.info(\"Add Middleware MSGPack\")\n        from msgpack_asgi import MessagePackMiddleware\n\n        self.add_middleware(MessagePackMiddleware)\n\n    def configure_context_middleware(self) -> None:\n        \"\"\"Add Middleware Context\"\"\"\n        self.logger.info(\"Add Middleware Context\")\n        from starlette_context.middleware import RawContextMiddleware\n\n        self.add_middleware(\n            RawContextMiddleware,\n            plugins=(plugins.RequestIdPlugin(), plugins.CorrelationIdPlugin()),\n        )\n\n    def configure_prometheus_instrument(self) -> None:\n        \"\"\"Add Prometheus Instrument and Expose App\"\"\"\n        self.logger.info(\"Prometheus Instrument and Expose App\")\n        from prometheus_fastapi_instrumentator import Instrumentator\n\n        Instrumentator().instrument(app=self).expose(\n            app=self,\n            include_in_schema=True,\n            tags=[\"service\"],\n            response_class=HTMLResponse,\n        )\n\n    def configure_csrf_middleware(self) -> None:\n        \"\"\"Add Middleware CSRF\"\"\"\n        self.logger.info(\"Add Middleware CSRF\")\n        from starlette_wtf import CSRFProtectMiddleware\n\n        self.add_middleware(CSRFProtectMiddleware, csrf_secret=getSecretKeyCSRF())\n\n    def configure_session_middleware(self) -> None:\n        \"\"\"Add Middleware Session\"\"\"\n        self.logger.info(\"Add Middleware Session\")\n        from starlette.middleware.sessions import SessionMiddleware\n\n        self.add_middleware(SessionMiddleware, secret_key=getSecretKeySessions())\n\n    def configure_background_scheduler(self) -> None:\n        \"\"\"Add Background Scheduler\"\"\"\n        self.logger.info(\"Add Background Scheduler\")\n        from apscheduler.schedulers.background import BackgroundScheduler\n\n        self.background_scheduler = BackgroundScheduler()\n        self.background_scheduler.start()\n\n    def configure_asyncio_scheduler(self) -> None:\n        \"\"\"Add Asyncio Scheduler\"\"\"\n        self.logger.info(\"Add Asyncio Scheduler\")\n        from apscheduler.schedulers.asyncio import AsyncIOScheduler\n\n        self.asyncio_scheduler = AsyncIOScheduler()\n        self.asyncio_scheduler.start()\n\n    def configure_event_loop(self) -> None:\n        \"\"\"Enable UVLoop\"\"\"\n        self.logger.info(\"Enable UVLoop\")\n        import uvloop\n\n        uvloop.install()\n\n    def configure_cors_middleware(self) -> None:\n        \"\"\" \"Add Middleware CORS\"\"\"\n        self.logger.info(\"Add Middleware CORS\")\n        from starlette.middleware.cors import CORSMiddleware\n\n        self.add_middleware(\n            CORSMiddleware,\n            allow_origins=self.settings.allow_origins,\n            allow_credentials=self.settings.allow_credentials,\n            allow_methods=self.settings.allow_methods,\n            allow_headers=self.settings.allow_headers,\n        )\n\n    def configure_timing_middleware(self) -> None:\n        \"\"\"Add Middleware Timing\"\"\"\n        self.logger.info(\"Add Middleware Timing\")\n        from fastapi_utils.timing import add_timing_middleware\n\n        add_timing_middleware(\n            self, record=self.logger.info, prefix=\"app\", exclude=\"untimed\"\n        )\n\n    def configure_gzip_middleware(self) -> None:\n        \"\"\"Add Middleware GZip\"\"\"\n        self.logger.info(\"Add Middleware GZip\")\n        from starlette.middleware.gzip import GZipMiddleware\n\n        self.add_middleware(GZipMiddleware)\n\n    def configure_httpsredirect_middleware(self) -> None:\n        \"\"\"Add Middleware HTTPSRedirectMiddleware\"\"\"\n        from starlette.middleware.httpsredirect import HTTPSRedirectMiddleware\n\n        self.logger.info(\"Add Middleware HTTPSRedirect\")\n        self.add_middleware(HTTPSRedirectMiddleware)\n"
        }
    ]
}